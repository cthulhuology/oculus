<!DOCTYPE html>
<html>
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0"/ >
<title>Dave's Life On Hold</title>
<base target="_parent" />
<link href='http://fonts.googleapis.com/css?family=Josefin+Sans:600,400' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Josefin+Slab:600,400' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/style.css" type="text/css">
<script type="text/javascript">var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-22003616-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })();
</script>
</head>
<body>
<h1>PgProc.lua and the Joy of Reflection</h1>
<div class="content">Tonight I&#39;ve released a bit of code derived from the some of the work that went into Evangelizmo. Back in 2010, I wrote a set of C functions which bound the stored procedures in an application specific schema for <a href="http://github.com/cthulhuology/Jawas">Jawas</a> to the globall namespace of the Lua or JavaScript runtime with the same names. With the <a href="http://luajit.org/ext_ffi.html">LuaJIT FFI extension</a>, I have ported the C + Lua code of the original to a pure Lua implementation as <a href="http://github.com/cthulhuology/pgproc.lua">pgproc.lua</a>.  The design of the API is to minimize those layers of code necessary to maintain in multiple places for any application.  Consider the code:<br><br>  require(&#39;pgproc&#39;).bind(&#39;object&#39;)<br>  print(object.create(&#39;{ "some" : "json" }&#39;)[&#39;create&#39;]))<br><br>This code will automatically connect to the database as specified by e <b>DB_CONNECT_STRING</b> environment variable, read the stored procedures out of the <I>objects</I> schema, and generate the appropriate Lua global <I>object</I> table with the associated functions as closures wrapping the stored procedure function call. If we create a <I>object.create</I> stored procedure in our database, that functionality is the immediately available by restarting the Lua process. It is possible to call <b>bind(schema)</b> at runtime to pick up additional changes as they occur. A long running process may periodically rebind the stored procedures every hour or so with little impact on performance. <br><br>If you&#39;ve never used a stored procedure, you&#39;re missing out on one of the greatest database design tools available. Rather than relying upon every programmer being a SQL ninja who can explain and analyze every query and data model to optimum performance, you can separate concerns between different programmers. Let&#39;s say your Big Data Architect has a crazy shared database architecture with dozens of individual machines coordinated via a set of proxies. As modern Postgres servers can define external resources, which themselves may be other Postgres databases, your simple join statement in your SQL query could be unintentionally spanning multiple datacenters. How are you to know you can&#39;t safely make that join in production with risking taking down the company?  After all, you&#39;re just trying to get a report to work for finance. Enter the stored procedure.  Rather than dealing with the data model directly and writing SQL, you invoke a function stored in the database which had been hand crafted by a domain expert. As the complexity of the infrastructure grows and the volume of queries exceeds what a handful of  smiple master/slave databases can handle, it becomes impractical for every member of every team which may consume that data to have to become a subject matter expert. Instead, the only way tomscalemthe human knowledge gap is to architect APIs with the limitations of the humans in mind.   Rather than know how it all works, all you need to know is the signature of the function.<br><br>With that in mind, pgproc.lua is designed to make the transition from a DB engine running on one machine to a globally distributed cluster of machines as painless as possible. Typically stored procedures still require you write the tedious wrapper functions to interface with your database. Since the catalog tables in Postgres already know all about the stored procedures and we can query the catalog tables from SQL, we can automate the binding process. Similarly, as LuaJIT FFi knows how to automate lithe binding process to the C routines of libpq, pgproc.lua even doesn&#39;t go any further than translating the minimal number of C header bits to support building the wrappers.  Most of the methods only exist to make it slightly easier to integrate the database connections with different configuration schemes.  Once bound, however, you need never even think of the database again.<br><br>One of the cool applications you can create with pgproc.lua is a simple CRUD application. By implementing create, read, update, and delete procedures and binding to a schema associated to a data type, you can trivially store objects in the DB. When used in conjunction with projects like <a href="http://github.com/cthulhuology/amqp.lua">amqp.lua</a>, you can further extend he reach of the simple CRUD pgproc.lua wrapper to a highly available distributed application. In about 10 lines of code, you can wire up your entire world. <br><br></div>
</body>
</html>